------------------1---------------------
film_in_stock - the function returns a list of inventory IDs (inventory_id) that correspond to the given film (p_film_id) and store (p_store_id), if those units are in stock
film_not_in_stock - the function returns a list of inventory IDs (inventory_id) that match the given film (p_film_id) and store (p_store_id) if those units are not in stock
inventory_in_stock - the inventory_in_stock function checks whether the inventory unit (inventory_id) is in stock
get_customer_balance -the function get_customer_balance calculates the current balance of a customer (p_customer_id) on a certain date (p_effective_date)
inventory_held_by_customer -the inventory_held_by_customer function determines which customer currently holds a particular inventory item (p_inventory_id), if not returned
rewards_report - the rewards_report function generates a report on customers who meet the specified criteria of a minimum number of purchases and total spending for the previous month
last_day - The last_day function determines the last day of the month for a given date



---------------2-----------------------

this function returns empty due to the fact that it takes 
data for the last three months from the current date last_month_start := CURRENT_DATE - '3 month'::interval;,
and the payment table has data only for 2017. In order to fix it, it is necessary

-------------------3-------------------------
In my opinion, the last_updated function is unnecessary,
 because the current date and time can be set via Default

--------------------------4--------------------------------------
New logic

create or replace function public.get_customer_bl(p_customer_id integer, p_effective_date timestamp with time zone)
returns numeric
language plpgsql
as $function$
declare
    v_rentfees decimal(5,2);
    v_overfees decimal(5,2);
    v_replacement_fees decimal(5,2);
    v_payments decimal(5,2);
begin
    -- 1) rental fees for all previous rentals
    select coalesce(sum(film.rental_rate), 0) into v_rentfees
    from film, inventory, rental
    where film.film_id = inventory.film_id
    and inventory.inventory_id = rental.inventory_id
    and rental.rental_date <= p_effective_date
    and rental.customer_id = p_customer_id;

    -- 2) one dollar for every day the previous rentals are overdue
    select coalesce(sum(
        case
            when rental.return_date is null 
                then extract(epoch from (p_effective_date - rental.rental_date))::integer / 86400
            when rental.return_date > rental.rental_date + (film.rental_duration * '1 day'::interval)
                then extract(epoch from (rental.return_date - (rental.rental_date + (film.rental_duration * '1 day'::interval))))::integer / 86400
            else 0
        end
    ), 0) into v_overfees
    from rental
    join inventory on rental.inventory_id = inventory.inventory_id
    join film on inventory.film_id = film.film_id
    where rental.rental_date <= p_effective_date
    and rental.customer_id = p_customer_id;

    -- 3) replacement cost for films overdue more than rental_duration * 2
    select coalesce(sum(
        case
            when rental.return_date is null 
                and p_effective_date - rental.rental_date > (film.rental_duration * '2 days'::interval)
                then film.replacement_cost
            when rental.return_date - rental.rental_date > (film.rental_duration * '2 days'::interval)
                then film.replacement_cost
            else 0
        end
    ), 0) into v_replacement_fees
    from rental
    join inventory on rental.inventory_id = inventory.inventory_id
    join film on inventory.film_id = film.film_id
    where rental.rental_date <= p_effective_date
    and rental.customer_id = p_customer_id;

    -- 4) subtract all payments made before the date specified
    select coalesce(sum(payment.amount), 0) into v_payments
    from payment
    where payment.payment_date <= p_effective_date
    and payment.customer_id = p_customer_id;

    return v_rentfees + v_overfees + v_replacement_fees - v_payments;
end
$function$;




------------------------------5-------------------------------------------
_group_concat is an intermediate function that combines two text values ​​with a comma. 
And group_concat uses _group_concat to sequentially combine values ​​in a group

-------------------------------------------------------------6------------------------------------------------------------------
We use the last_updated function to mark the time when we made changes to the table.
This function is used in all tables of the dvd_rental database as a default value and is an indicator of when
a record was entered into the fbo table and changed.

------------------------------------------------------------------------7------------------------------------------------------


The tmpSQL variable in this function is used for dynamically forming SQL queries. This approach allows:
create requests with variable values ​​(dates, amounts, number of purchases);
perform various SQL operations within one function (creating a table, inserting data, deleting);
modify the query based on input parameters; 
This function can be reproduced without it and it will be better, because such disadvantages as: the risk of SQL injections will disappear;
more complex code support;
worse performance due to the creation of temporary tables;
more complex optimization of PostgreSQL queries;



